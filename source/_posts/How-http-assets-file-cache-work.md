---
uuid: ed0c2e60-2a20-11ea-890e-750556bf0e3a
title: Http 静态文件缓存是怎么工作的
s: How-http-assets-file-cache-work
date: 2019-12-29 17:52:29
tags:
categories:
coauthor: chenyunjie
---

现在的网站都会有很多静态文件需要加载，比如js、css文件，当用户浏览时，浏览器就会下载这些文件，
但是这些文件内容一般是不会频繁变动的（每天都上线的除外），如果用户每次浏览这个文件都需要重新下载，那岂不是很傻？

幸运的是浏览器会缓存这些静态文件，当用户再次访问的时候不会重新请求，而是直接从缓存获取，这样大大缩短了页面加载时间。

![image.png](https://i.loli.net/2019/12/29/cRGEfN7MLOouk2V.png)
从上图我们可以看到这个get请求直接从缓存获取了数据。

结束了吗？

No

有个问题，大家都是http请求，凭什么浏览器会缓存静态文件，而不缓存api请求呢？

答案是浏览器真不知道该缓存哪些请求，这是由服务器告诉浏览器的。

![image.png](https://i.loli.net/2019/12/29/1Yvrcl32wOybhIG.png)

从上面的图片中我们可以看到，浏览器请求这个静态文件的时候，响应头会有一个 Cache-Control: max-age=315360000，这是用来告诉浏览器：缓存这个请求的内容315360000s，当用户在315360000s内再次访问的时候，浏览器就会直接去缓存获取内容，而不是发一个新的请求。

关于Cache-Control可以查看mdn：
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control

那这个Cache-Control是怎么来的呢？
静态文件一般是 nginx 来 server 的，我们看一下nginx配置：

```
  location ~ ^/(static)/  {
      expires max;
  }
```

上面的配置文件是说如果某个请求的路径是以/static/开始的，则给这个请求的响应头添加 Cache-Control: 315360000s。然后浏览器接收到这个请求头就知道应该把这个静态文件缓存10年。

具体可以查看nginx文档：
http://nginx.org/en/docs/http/ngx_http_headers_module.html


那么问题又来了！假如这个网站更新了 js 代码，修复了某个 bug，但是10年还没有过去，用户在访问的时候还是会遇到bug，因为他的浏览器并不会去重新请求新的js文件。

那么就有两个办法：
1. 等十年😄
2. 让用户手动清除一下浏览器缓存。


这两个方法都不太可行。

那怎么办呢？还有两个办法：

1. 在静态文件后面加Query String

比如vendors.js?v=1.0，一般我们会在所有静态文件后面加一个版本号，当我们更新了文件后变更版本号，
vendors.js?v=1.1, 这样用户再次浏览的时候就会去服务器请求新的js文件，因为浏览器是按请求的完整路径来缓存的，现在请求的完整路径变了，在缓存中获取不到东西，自然就会去服务器获取。
> tc原先就是这样干的。

但这种方有不好的地方：一般我们会给所有的静态文件加同样的版本号，比如软件的版本号，这样就算只改了一个js文件，本站所有静态文件都会全部重新加载。这还不是最关键的，这个办法最要命的缺陷在于，同一个静态文件在服务器上只能保存一份，新版本的文件会替换掉旧版本，因为他们的文件名是一样的，这在大多数情况下是没有问题的，但在一些场景下就会有问题，比如进行灰度发布。

2. 在静态文件的名称中增加Content Hash

比如vendors.e0674cdac9ce5190ff76.js，其中e0674cdac9ce5190ff76就是由vendors.js的内容计算出来的，这样当内容变化的时候这个hash值会跟着变化。这样就解决了让缓存失效的问题。而且因为新版和旧版文件名称不一样，这两个版本的文件都可以保存在服务器上。
> 在 js 打包工具切换到webpack后，现在的tc已经采用这种方式。
